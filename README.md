# custom_shell
a shell that can compose multiple programs, manage jobs, and best of all, it will use the modern posix_spawnp interface rather than the sad old fork interface.

$ command arg1 arg2 ... Run command, with stdin and stdout connected to their usual files. 

$ command args < input_redirection Run the command, but connect stdin to the contents of the file input_redirection.

$ command args > output_redirection Run the command, but connect stdout to the contents of the file output_redirection.

$ command args < input_redirection > output_redirection Do both of the previous tasks at the same time.

$ command1 args | command2 args Run command1 as in #1, but redirect the output of command1 as input to command2.

$ command1 args ; command2 args Run command1 as in #1, wait for it to finish, and then run command 2 as in #1.

$ command1 args && command2 args Run command2 as in #1 if and only if command 1 returns zero exit status.

When any non-background command finishes, the parent should output the prompt again as normal. However, if the user executes the special command ?, the shell should output \npid:%d status:%d\n (with the proper relevant values inserted into the format string), and then print the prompt again and wait for more input. For composed commands (i.e., pipes), the output should only be shown for the final command in the sequence.

Your shell should handle the following signals:
SIGINT - Generated by Ctrl-C. This signal allows a user to terminate a running program. Your shell should NOT exit when user presses Ctrl-C or the process receives SIGINT but simply report that the SIGINT signal has been received by the shell. If the process receives SIGINT, you must print the string "caught sigint" on a line by itself, and then show the prompt again.

SIGTSTP - Generated by Ctrl-Z. This signal allows a user to pause a running program. Your shell should not exit when user presses Ctrl-Z or the process receives SIGTSTP but simply report that the SIGTSTP signal has been received by the shell. If your shell receives SIGTSTP, you must print the string "caught sigtstp" on a line by itself, and then show the prompt again.

SIGCHLD - Generated when a child process has stopped or terminated. If a background command (e.g. sleep 10 &) executes in your shell, the parent should run this command in the background and immediately print the prompt without waiting for the child process to terminate. Additionally, the parent process must reap the children processes and and avoid leaving zombie processes. Your shell does NOT require to track background child process's status.



Using input redirection to test a shell#

One important concept we'll go over this week is file redirection. In short, file redirection allows you to read your program's input from a file, rather than from the keyboard.

For instance, if you have a file input that has the lines:
pwd
ls
date +%Y%m%d

You can feed it to a new instance of a shell program by redirecting the input from that file by adding the < character as an argument, then the name of the file:

cs361@home-desktop:~/repos/shell-skel$ sh < input 

In addition to using sh, you can also run the skeleton code for the assignment in the same way (i.e., your-program < input), and see that it works properly. If you would like to automate the process of comparing the output of a real shell with your shell, you can use the diff program. Running man diff at the command line or googling diff command linux can give you a good introduction to how it works.
